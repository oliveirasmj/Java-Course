----------------------JAVA BASICO------------------------------
HelloWorld.class (depois de compilados dao origem a class)
HelloWorld.java (source code)
Compiler (é compilado para bytecode e executado no JVM) - compilador - transforma em linguagem maquina
JVM - Java virtual mahine

Scanner
Scanner sc = new Scanner(System.in);
String str = sc.nextLine();

Ao criar uma variavel nao objeto é defido um quadrado com o valor la dentro
Num objeto é criado um quadrado com a posição da memória

Vantagens POO:
-Duplicação de código
-Responsabilidades em cada classe

Locale.setDefault(Locale.US); //mudar regiao por causa da virgula e ponto - casas decimais
double x = 10.2626452; int y = 3; String var = "ola"; char letra = 'A';
soutf("Double: %f - Inteiro: %d - String: %s - Letra: %c", x, y, var, letra);

int a=5, b=2; System.out.println(a/b); System.out.println((double)a/b); //Truncado e valor real

System.out.print("Individual or company (i/c)? ");
char type = sc.next().charAt(0);

//INCREMENTO
//num=num+1
//num+=1
//num++  --> valor antigo será usado para o cálculo
//++num  --> valor antigo não será usado para o cálculo

Math.pow(5, 2)
Math.sqrt(25)

Membros de instância vs Membros estáticos/de classe
-Membros de instância tem valor diferente para cada objeto  +  É preciso instanciar
-Membros estáticos tem o mesmo valor para diferentes objetos (chamados com o nome da classe: Math.sqrt()) + não é preciso instanciar (usados para dados e funções que nunca se irão modificar)


---------------------CLASSES E OBJETOS-----------------------------
Classe - representa categoria de algo (descreve caracteristicas) - modelo
Objeto - instância de uma classe - tem atributos (cor)
	Classe: int cor -> Objeto cor: vermelho
Método - é uma função que retorna algo (int/void) ou modifica(setter)
Carro c = new Carro( );

-Primitivo VS Referencia
int number; number = 35;		number|35|
Customer cust; cust = new Customer;	cust| |-------> |:Custormer|

number2 = number			number|35| number2|35|
Customer cust2; cust2=cust		cust| |-------> |:Custormer|
					cust2| |------->

private String txt; //txt = null


---------------------DEFINICAO CLASSES-----------------------------
Construtor - é o que é executado na instânciação do objeto (iniciar valores) - método para iniciar os objetos (receber valores)
Sobrecarga/Overloading - mais de um construtor (varios parametros) - com o mesmo nome
Encapsulamento - consiste em esconder detalhes de implementação (getters e setters e modificadores private)

This - referência para o próprio objeto (distinguir atributos e variaveis locais ou passar objeto como argumento)
Os campos devem ser privados e os metodos publicos para serem usados

Modificadores - public, private, protected
-public - visiveis por todas as classes
-private - visiveis dentro da classe
-protected - visiveis dentro da package
-(default) - visiveis dentro da package

public String toString() {
	return getId() + ", " + getName() + ", " + String.format("%.2f", getSalary());
}	

---------------------INTERACAO ENTRE OBJETOS-----------------------------
-Triangle x = new Triangle(); x.area()-> 6 --> Membros de instância (valor para cada objeto - correto)
-Triangle y = new Triangle(); x.area()-> 4 --> Membros de instância (valor para cada objeto - correto)

-Calculator calc1 = new Calculator(); calc1.PI()-> 3.14 --> Membros estáticos (não totalmente certo)
-Calculator calc2 = new Calculator(); calc2.PI()-> 3.14 --> Membros estáticos (não totalmente certo)
-double c = Calculator.PI -> Membros estáticos - Não é preciso instanciar objetos (o mais correto)

Apenas "métodos static" podem ser chamados no public static void main(String[] args) {}
Para chamar diretamente um método de uma classe(sem instanciar - Classe.metodo() ), então o método terá de ser "static"

private static int numAlunos = 0; //mesmo valor	para todas os objetos

---------------------MEMÓRIA/ARRAYS/LISTAS(AGRUPAMENTO DE OBJETOS)-----------------------------
Tipos de variáveis:
-Tipos de Valor (primitivos) - caixas em que valor fica lá dentro - boolean, byte, char, short, int, long, float, double
-Tipos de Referência - classes (através de ponteiros) - posição da memória fica lá dentro - Stack ------> Heap

Garbage collector - monitoriza os objetos alocados pelo programa (no heap) e desaloca os que não estão a ser utilizados
Ou seja - se o ponteiro desaparecer o que está no solto no Heap desaparece
Product P1 = new Product(...);
Product P2 = new Product(...);
P1 = P2;
//O que está no Heap do P1 (para onde apontava) será eliminado, pois apontará para o mesmo de P2

Desalocação por escopo - elimina as váriáveis primitivas que não serão precisas (p. ex. dentro de um if)

Wrapper classes - classes equivalentes aos tipos primitivo - Double(wrapper classe) e double(primitivo)
-usado para converter valores entre os dois tipos(ex. String to int)

-------
Array/Vetor: dados do mesmo tipo ordenados por posições
-vantagens: acesso imediato aos elementos pela posição
-desvantagens: tamanho fixo e dificuldade para inserir e eliminar

private String[] vect = new String[10] //tamanho definido de array de Strings
private String[] names = new String[] {"Mike", "Pedro", "Carlos"};

------
Matriz - é o nome dado a arranjos bidimensionais (do mesmo tipo, odenada)
Vantagens: acesso imediato aos elementos pela posição
Desvantagens: tamanho fixo, dificuldade para inserir e eliminar

private int[][] mat = new int[n][n]; //criacao de vetor com n elementos

//Percorrer matriz	
for(int i=0; i<n; i++) {
	for(int j=0; j<n; j++) {
		mat[i][j] = sc.nextInt();
	}
}

-----
Boxing: conversão de um objeto valor para um objeto referência
int x = 20; Object obj = x;
UnBoxing: conversão de um objeto referência para um objeto valor
int x = 20; Object obj = x; int y = (int) obj;

FOR VS FOREACH:

String[] vect = new String[] {"Mike", "Pedro", "Carlos"};
for(int i=0; i<vect.length; i++){
     sout(vect[i]);
}
for(String obj : vect){
     sout(obj);
}

-------
List:
-é uma estrutura de dados 
-do mesmo tipo
-ordenada
-inicia vazia, sem dizer o valor inicial
-cada elemento é um nó
-não é uma classe, é uma interface - não pode ser instanciada
	private List<String> list = new List<>(); -- ERRADO - nao se pode instanciar uma interface

Classes que implementam List: ArrayList, LinkedList, etc - forma de instanciar
	private List<String> list = new ArrayList<>(); -- CERTO - criar uma lista implementando o arraylist

Vantagens: 
-tamanho variável e facilidade para inserir e eliminar
Desvantagens: 
-acesso sequencial - é preciso percorrer toda a lista para chegar a um elemento
-tipo de dados não pode ser primitivo, apenas o wraper

Coleções: ArrayList(listas de objetos), HashMaps(mapeia chaves para valores)
https://www.guj.com.br/t/por-favor-qual-e-a-diferenca-dentre-arraylist-e-list/69167/2
NAO PODE SER TIPO DADOS PRIMITIVO
add, get, size, remove, etc...

Adicionar elementos de forma imediata: List<Integer> list = Arrays.asList(3, 4, 5, 10, 7);
------
***Datas***
SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy"); 
SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:ss");
private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy"); //static - para que nao seja instanciado

System.out.print("Bith date (DD/MM/YYY): "); //inserir data
Date birthDate = sdf.parse(sc.next()); //instanciar data
System.out.print(sdf.format(birthDate)); //imprimir

Date birthDate2 = new Date(); //data atual
System.out.println(sdf.format(birthDate2)); //imprimir

***Subtrair datas***
public long duration() {
	long diff = checkOut.getTime() - ckeckIn.getTime(); //subtrai ao duas datas em milisegundos
	return TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS); //converte para dias
}

------
Append:
public String toString() {
	StringBuilder sb = new StringBuilder();
	sb.append("Order moment: " + sdf.format(moment) + "\n");
	sb.append("Order status" + status + "\n");
	sb.append("Client: " + client + "\n");
	return sb.toString();
}

-------
Enumerados: conjunto de nomes significativos (exemplo: ciclo de vida de uma encomenda)
public enum OrderStatus {
	PENDING_PAYMENT,
	PROCESSING,
	SHIPPED,
	DELIVERED;
}

System.out.print("Introduza o status: "); OrderStatus status = OrderStatus.valueOf(sc.next());

------
Composição - é um tipo de associação que permite que um objeto contenha outro (diamante preto)
(Relação tem-um ou tem vários)

public class Order {
	private Date moment;
	private OrderStatus status;
	private Client client; //uma encomenda pode ter um cliente (tem referência para o Cliente)
	private List<OrderItem> orders = new ArrayList<OrderItem>(); //uma encomenda pode ter vários OrderItem
}

------
Iterações:
foreach - percorre ate ao fim, nao pode ser alterada (nao remove)
while - nao precisa ir ate ao fim
Iterator - nao precisa ir ate ao fim - listar, remover


-------------------HERANÇA, POLIMORF, INTERFACE---------------------------

Herança - é uma forma que permite que uma classe herde todos os dados da outra - classes pai/filho (extends) - lê-se "é um"
-Classe Pai = generalização/superclasse; Classe filho = especialização/subclasse
-VANTAGENS: evita repetição de código e no caso de ser vir a alterar codigo
Animal -> Mamifero e Reptil -> Cão -> Dalmata
-------
public class Carro extends Veiculo{
	private Integer numCavalos;

	public Carro() {
		super();
	}
	
	public Carro(Integer numRodas, Integer numCavalos) {
		super(numRodas);
		this.numCavalos = numCavalos;
	}
	
	public void chamarMetodo(){
		//System.out.println(super.getNumRodas()); //chamar um metodo da superclasse
	}
}
-------
Métodos são herdados por todas as classes
Sobreposição - é a implementação de um método da superclasse na subclasse - @override

Polimorfismo - permite que variaveis de um mesmo tipo apontem para objetos de tipos diferentes, tendo comportamentos diferentes
Account x = new Account(); //possui todos os atributos de Account
Account y = new SavingsAccount(); //possui todos os atributos de Account mais os de SavingsAccount - converte para SavingsAccount 
//Tanto x como y são variáveis do mesmo tipo (Account), mas os objetos instânciados são de tipos diferentes na memória

x.withdraw(50.0); 
y.withdraw(50.0);
//Métodos com comportamentos diferentes caso o withdraw de y(SavingsAccount) seja implementado de forma diferente

Outra vantagem: quando se colocam numa coleção(lista), a lista só pode ser de um tipo, logo será do tipo Account

-----
//Sobreposicao
@Override
public void withdraw(double amount) { //chamar método da superclasse e escrever o código à nossa maneira
	super.withdraw(amount); //Escrever código igual à super classe
	balance -= 2.0; //Mas aplicar uma taxa
}
-----
Upcasting - casting da subclasse para superclasse (polimorfismo)
Downcasting - casting da superclasse para subclasse (instance of, equals)

public static void main(String[] args) {	
	Veiculo v = new Veiculo();
	Carro c = new Carro();
	Veiculo xpto = new Carro();

	v.getNumRodas(); // o que v consegue ver
	c.getNumRodas(); c.getNumCavalos(); // o que c consegue ver
	xpto.getNumRodas(); // o que xpto consegue ver
		
	// UPCASTING - converter veiculo em carro
	Veiculo v2 = c; // não dá erro porque carro é um veículo
	Veiculo v3 = new Carro(); //outra forma - não dá erro porque carro é um veículo
		
	// DOWNCASTING - converter carro em veiculo
	//Carro c2 = v; //Não se pode converter de Veiculo para carro
	Carro c2 = (Carro) v3; //Fazendo a conversao manual já é possível converter para Carro
		
	//Verificar se um objeto é um Carro
	if(v3 instanceof Carro) {
		System.out.println("É um carro");
	}
}

-----
Instance of (é um) - verifica se um objeto é de um tipo de classe
Ferrari ferrari = new Ferrari();
if (ferrari instance of Vehicle)
-----
final
(campos - valor não altera) ---> private final int MAX_ALUNOS_TURMA = 25 //constante valor fixo
(classe - evita que classe seja herdada) - final class Veiculo
(método - evita que método seja sobreposto) - public final void contarKms()


-------------------CLASSES ABSTRATAS---------------------------
Classes abstratas: são classes que não podem ser instanciadas
Exemplo:
SavingsAccount e BusinessAccount extendem Account(que é abstract), ou seja não existe se pode criar uma conta comum, apenas SavingsAccount ou BusinessAccount 
	
Métodos abstratos: não têm corpo(implementação) na classe pai - mover()
Apenas tem corpo na classe filho - voar, nadar, saltar...

public abstract class Shape { //Classe abstrata - nao pode ser instanciada
	private Color color;
	public Shape() {
	}
	(...)
	public abstract Double area(); //Método abstrato - obriga subclasses a usarem o método
}


-------------------INTERFACES---------------------------
É um conjunto de métodos vazios que são implementados noutra classe
A interface estabelece um contrato que a classe deve cumprir
Todas as classes que implementam uma interface sao subtipos dessa interface

public interface TaxService {
	double tax(double amount);
}

public class BrazilTaxService implements TaxService{
	public double tax(double amount) { 
		if (amount <= 100.0) {
			return amount * 0.2;
		}
		else {
			return amount * 0.15;
		}
	}
}

-----------------
Inversao de controlo - padrao de desenvolvimento que consiste em retirar as dependências
Injeção de dependência - é uma forma de realizar inversão de controlo: através do construtor por exemplo

public class Program {
	public static void main(String[] args){
		RentalService rentalService = new RentalService(pricePerDay, pricePerHour, new BrazilTaxService()); //BrazilTaxService - injecao de dependencia por meio de construtor - classe RentalService
	}
}

public class RentalService {
	private Double pricePerDay;
	private Double pricePerHour;
	private TaxService taxService; //tem uma associacao com a interface TaxService (em vez de BrazilTaxService)

public RentalService(Double pricePerDay, Double pricePerHour, TaxService taxService) { //Upcasting - injeção de dependência por meio de construtor
		this.pricePerDay = pricePerDay;
		this.pricePerHour = pricePerHour;
		this.taxService = taxService; //TaxService - aqui é recebida uma classe que implemente uma TaxService - upcasting
	}
}

-----------------
---Herdar vs Cumprir Contrato---

Herança: Existe uma classe abstrata com as subclasses que a herdam (reuso de código)
Interface: existe umma interface com as as classes concretas implementando a interface (contrato a ser cumprido)
Em ambos existe a relação É UM 
Em ambos existe Tipos Generico e Tipo Especifico
Em ambos existe Polimorfismo

https://www.devmedia.com.br/interfaces-x-classes-abstratas/13337


---Herança Multipla---
A herança múltipla pode gerar o problema do diamante
Nao é permitida na maioria das linguagens

1)
public class ComboDevice extends Scanner, Printer
-->DÁ ERRO

2)
public class Program {
	ComboDevice c = new ComboDevice("2081"); //Este implementa o Printer e o Scanner
}
public class ComboDevice extends Device implements Scanner, Printer {...}
public interface Printer {...} public interface Scanner {...}
ASSIM JÁ É POSSÍVEL

-------------------DEFAULT METHODS---------------------------
A partir do Java 8 é possível definir métodos com código dentro de interfaces fornecendo uma implementação default.
Assim evita-se que em cada classe que implemente a interface se esteja a repetir o código

public interface InterestService {

	double getInterestRate();

	default double payment(double amount, int months) {
		if (months < 1) {
			throw new InvalidParameterException("Months must be greater than zero");
		}
		return amount * Math.pow(1.0 + getInterestRate() / 100.0, months);
	}
}

public class BrazilInterestService implements InterestService {

	private double interestRate;

	public BrazilInterestService(double interestRate) {
		this.interestRate = interestRate;
	}

	@Override
	public double getInterestRate() {
		return interestRate;
	}
}

public class Program {
	InterestService is = new BrazilInterestService(2.0);
	double payment = is.payment(amount, months);
}

----------------Comparable---------------------
public class Program {
public static void main(String[] args) {
	List<Employee> list = new ArrayList<>();
	Collections.sort(list); //FORMA DE ORDENAR UMA COLEÇÃO ------> list tem de ser do tipo COMPARABLE ------> Employee implements Comparable
}
}

public class Employee implements Comparable<Employee> {
(....)
@Override
	public int compareTo(Employee o) { //compara um objeto com outro - devolve negativo, 0 ou positivo se for alfabeticamente menor, iigual ou maior
		return name.compareTo(o.getName()); //ordenar por nome
		//return salary.compareTo(o.getSalary()); //ordenar por salario
		//return -salary.compareTo(o.getSalary()); //ordenar por salario descrescente
	}
}

-------------------------------EXCEPÇÕES---------------------------------
Excepção - é uma condição de erro - programação defensiva
Lançamento e tratamento de exceções
Reporte de erros

Herdado da Classe: 
- Exception: obriga a tratar excepção com try catch ou throws
- RuntimeException: não obriga a tratar

Objetivo: prevenir que erros afectem o sistema

Remover aluno com id que não existe
try - instruções a proteger
catch - reportar(caso seja capturada algo no try)
finally - bloco executado independentemente de ter ocorrido ou não uma excepção

RuntimeException - compilador nao obriga a tratar - programa termina
Exception - compilador obriga a tratar - programa não termina
Cláusula throws: lança a exceção verificada ao invés de trata-la (caso nao se faça try catch)

-----
A palavra reservada throws vai na assinatura do método e indica que este método poderá lançar uma exceção que deve ou ser relançada ou capturada pelo método que a está chamando.
public void foo (int x, int y) throws Exception 

A palavra reservada throw new serve para lançar a exceção de dentro do corpo do método como em:
try { // Faz algo } catch(Exception e){ throw new Exeption(); }
-----

***Program***
try {
	String[] vect = sc.nextLine().split(" "); //ler varios dados na mesma linha separados por espaço em branco
	int position = sc.nextInt();
	System.out.println(vect[position]);
}
catch (ArrayIndexOutOfBoundsException e) { //Excepcao que é gerada quando o número não está dentro dos limites
	System.out.println("Invalid position");
}
catch (DomainException e) { //Excepcao que nós criamos
	System.out.println("Erro in reservation: " + e.getMessage());
}
catch (Exception e) { //Para qualquer tipo de excepção
	System.out.println("Unexpected error");
}
finally {
	System.out.println("Sou sempre executado");
}
System.out.println("End of program"); //Agora mensagem já é apresentada com limite invalido ou com letra

***Reservation***
public Reservation(Integer roomNumber, Date checkIn, Date checkOut) throws DomainException {
	if (checkOut.before(checkIn)) { //se checkin/checkout for inferior a data atual
		throw new DomainException("Check-out date must be after check-in date"); //lança DomainException - é necessário trata-la colocando o throws em cima
	}
	this.roomNumber = roomNumber;
	this.checkIn = checkIn;
	this.checkOut = checkOut;
}

***DomainException***
public class DomainException extends Exception { // Exception - tem de tratar excepção com try catch ou throws |||| //RuntimeException - não tem de ser tratada
	public DomainException(String msg) {
		super(msg); // passar para o construtor da superclasse
	}
}

-------------------------------ARQUIVOS---------------------------------
File - Representação abstrata de um arquivo e seu caminho
FileReader (stream de leitura de caracteres a partir de arquivos)
BufferedReader (mais rápido - utiliza buffer de memória) - instanciado a partir do FileReader

Bloco try-with-resources - é um bloco try que declara recursos e garante que eles serão fechados no final(não é preciso fecho manual)

FileWriter (stream de escrita de caracteres em de arquivos)
BufferedWriter (mais rápido) - instanciado a partir do FileWriter

-----
File file = new File("C:\\Users\\luisp\\Downloads\\Estudo\\Udemy\\JavaCompleto2020\\17_Arquivos\\in.txt"); //criar objeto do tipo file passando o caminho
Scanner sc = null;

//Classe para ler arquivo	
try { 								//é preciso try porque o programa vai tentar abrir o arquivo
	sc = new Scanner(file); 				//instanciar scanner a partir do arquivo
	while(sc.hasNextLine())	{				//enquanto existir proxima linha
		System.out.println(sc.nextLine());		//imprimir a linha
	}
} 
catch (IOException e) {
	System.out.println("Error: " + e.getMessage());
}
finally {
	if(sc != null) { //apenas se tiver sido instanciado fechar do scanner
		sc.close();
	}
}
------

//Classe para ler arquivo com FileReader
String path = "C:\\Users\\luisp\\Downloads\\Estudo\\Udemy\\JavaCompleto2020\\17_Arquivos\\in.txt"; 	// caminho do arquivo
try(BufferedReader br = new BufferedReader(new FileReader(path))) {
	String line = br.readLine(); // se arquivo estiver no final é devolvido nulo
		while (line != null) { // enquanto nao estiver no final
			System.out.println(line); // escrever a linha
			line = br.readLine(); // ler a linha
		}
} catch (IOException e) {
	System.out.println("Error: " + e.getMessage());
}
------

//Classe para gerar um arquivo
String[] lines = new String[] { "Good morning", "Good afternoon", "Good night" };
String path = "C:\\Users\\luisp\\Downloads\\Estudo\\Udemy\\JavaCompleto2020\\17_Arquivos\\out.txt"; // caminho final para o arquivo
		
//try(BufferedWriter bw = new BufferedWriter(new FileWriter(path))) {
try(BufferedWriter bw = new BufferedWriter(new FileWriter(path, true))) { //true - indicar que não é para recriar arquivo
	for(String line : lines) { 	//para cada linha do array
		bw.write(line); 		//escrever na linha o texto da posicao do array
		bw.newLine(); 			//dar quebra de linha
	}
} catch (IOException e) {
	e.printStackTrace();
}

-----
//Ler ficheiro CSV
String line = br.readLine();
while (line != null) { //percorrer o ficheiro até ao fim
	String[] fields = line.split(","); //parar quando encontra virgula
	list.add(new Product(fields[0], Double.parseDouble(fields[1]))); //adicionar cada linha à lista de produtos
	line = br.readLine();
}

-------------------------------GENERICS, SET, MAP---------------------------------
Permite que classes, interfaces e métodos possam ser parametrizados por tipo:
List<T> list = new ArrayList<>(); //Tipo T - pode ser de todos os tipos(String, Integer,...)

Vantagens: 
- evitar casting excessivos
- reuso/reaproveitamento: devolver o primeiro item de uma lista independentemente do tipo(String, Integer,...): 
	public T first() { 
		return list.get(0); 
	}

Uso comum: coleções
Principal vantagem: reuso do código independentemente do seu tipo (não é necessário um código para String, Integer, ...)
Se for necessário mudar o tipo de variável de uma lista no main, não é preciso alterar código da outra classe porque é do tipo <T>

public class PrintService<T> { //Tipo T
	
	private List<T> list = new ArrayList<>(); //Tipo T - pode ser de todos os tipos(String, Integer,...)

	public void addValue(T value) {
		list.add(value);
	}
}
------

public class Program {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		//agora é do tipo Integer - sendo que a classe PrintService é Generics <T> pode ser de todos os tipos
		PrintService<Integer> ps = new PrintService<>(); //posso mudar de Integer para o que for desejável

		System.out.print("How many values? ");
		int n = sc.nextInt();
		
		//ps.addValue("Maria"); //agora já não é permitido porque só pode aceitar inteiros

		for (int i = 0; i < n; i++) {
			int value = sc.nextInt();
			ps.addValue(value);
		}
}

---> Outro exemplo: aula204_GenericsDelimitadosV2

---------------
List<Object> não é o supertipo de qualquer tipo de lista:
	List<Object> myObjs = new ArrayList<Object>();
	List<Integer> myNumbers = new ArrayList<Integer>();
	myObjs = myNumbers; // erro de compilação

O supertipo de qualquer tipo de lista é List<?>. Este é um tipo curinga:
	List<?> myObjs = new ArrayList<Object>();
	List<Integer> myNumbers = new ArrayList<Integer>();
	myObjs = myNumbers;

---------------
//Imprimir lista de qualquer tipo - Curinga
public static void main(String[] args) {
	List<Integer> myInts = Arrays.asList(5, 2, 10);
	printList(myInts);
	
	List<String> myStrs = Arrays.asList("A", "B", "C");
	printList(myStrs);
}

//public static void printList(List<Integer> list) {
public static void printList(List<?> list) { //assim imprime uma lista de qualquer tipo ---> <?>  MAS NÃO É POSSÍVEL ADICIONAR, SÓ LISTAR
	for (Object obj : list) {
		System.out.println(obj);
	}
}
-------------
//COVARIANCIA: get - OK; put - ERROR
List<Integer> intList = new ArrayList<Integer>();
List<? extends Number> list = intList; //Criar list (de qualquer tipo que seja SUBTIPO de Number) e copiar para inList
//Subtipo de Number é Integer, Byte, Long, Short, Float e Double
Number x = list.get(0);
//list.add(20.2); //erro de compilacao - nao da para adicionar a uma lista generica pois o valor pode nao ser Integer e neste caso é double

//CONTRAVARIANCIA: get - ERROR; put - OK
List<Object> myObjs = new ArrayList<Object>();
List<? super Number> myNums = myObjs; //Criar myNums (de qualquer tipo que seja SUPERTIPO de Number) e copiar para myObjs
//Supertipo de Number é Object
myNums.add(10); //já é possível adicionar
myNums.add(3.14); //já é possível adicionar
//Number x = myNums.get(0); // erro de compilacao - Number é SUBTIPO de object


------HashCode e Equals------
São operações da classe Object para comparar se um objeto é igual a outro (retorna true ou false)
Equals: lento, resposta 100%
HashCode: rápido mas reposta não é 100%

String a = "Maria";
String b = "Alex";
System.out.println(a.equals(b)); //retorna false porque não são iguais
System.out.println(a.hashCode()); //gera um código de 32bits para cada texto
System.out.println(b.hashCode()); //gera um código de 32bits para cada texto
//mas se os códigos forem iguais certamente os objetos são iguais
//se forem diferentes há uma pequena probabiblidade de serem iguais
-----------

//Foi gerado na classe Client um metodo hashCode e equals de modo a comparar com o nome e email
//Botão Direito - Source - Generate HashCode() and Equals()... - Selecionar os que se pretende comparar

Client c1 = new Client("Maria", "maria@gmail.com");
Client c2 = new Client("Maria", "alex@gmail.com");

System.out.println(c1.hashCode());
System.out.println(c2.hashCode());
System.out.println(c1.equals(c2));

System.out.println(c1 == c2); //retorna falso porque as posicoes de memoria sao diferentes, mesmo que sejam iguais

---------Set---------
Set<T>
Set: é um tipo genérico
Não admite repetições
Não possuem posição

Principais implementações: 
-HashSet: mais rápido e não ordenado alfabeticamente
-TreeSet: mais lento e ordenado alfabeticamente pelo CompareTo
-LinkedHashSet: velocidade intermédia e elementos na ordem em que são adicionados

Alguns métodos:
• add(obj), remove(obj), contains(obj) - Baseado em equals e hashCode (senão é usada comparação de ponteiros)
• clear()
• size()
• removeIf(predicate)
• addAll(other) - união: adiciona no conjunto os elementos do outro conjunto, sem repetição
• retainAll(other) - interseção: remove do conjunto os elementos não contitos em other
• removeAll(other) - diferença: remove do conjunto os elementos contidos em other

--------Set Exemplo--------
//Set<String> set = new HashSet<>(); //instanciar um Set usando a implementação HashSet (mais rápida) mas NÃO GARANTE ORDEM
//Set<String> set = new TreeSet<>(); //instanciar um Set usando a implementação TreeSet (mais lento) e GARANTE ORDEM ALFABÉTICA
Set<String> set = new LinkedHashSet<>(); //instanciar um Set usando a implementação LinkedHashSet (velocidade meia) e GARANTE ORDEM COLOCADA

set.add("Tv");
set.add("Tablet");
set.add("Notebook");

set.remove("Tablet"); //remover o "Tablet"
set.removeIf(x -> x.length()>3); //remover todos os que têm mais do que 3 caracteres
set.removeIf(x -> x.charAt(0) == 'T'); //remover todos os que têm a primeira letra T
System.out.println(set.contains("Notebook")); //ver se existe o elemento "Noteboook" no conjunto

for (String p : set) {
	System.out.println(p);
}

--------Set(HashSet)--------

Set<Product> set = new HashSet<>();

set.add(new Product("TV", 900.0));
set.add(new Product("Notebook", 1200.0));
set.add(new Product("Tablet", 400.0));

Product prod = new Product("Notebook", 1200.0); //instanciar um novo produto igual a um do conjunto

System.out.println(set.contains(prod)); //testar se o produto existe no conjunto
//da falso porque a classe produto nao contem os metodos HashCode e Equals - compara por referencia de ponteiros e não por conteudo
//SOLUCAO: colocar os metodos hacode e equals nao classe Produto - pois assim compara pelos valores

set.add(prod); //ele vai portanto colocar porque pensa ser diferente - se tiver HashCode e Equals na classe Product já não adiciona, pois compara pelos valores
System.out.println();
for(Product p : set) {
	System.out.println(p.getName() + " - " + p.getPrice());
}

--------Set(TreeSet)--------

Set<Product> set = new TreeSet<>(); //mais lento e ordenado alfabeticamente pelo CompareTo

set.add(new Product("Tv", 900.0));
set.add(new Product("Notebook", 1200.0));
set.add(new Product("Tablet", 400.0));

for (Product p : set) {
	System.out.println(p);
}

//Na classe produto
@Override
public int compareTo(Product other) {
	return name.toUpperCase().compareTo(other.getName().toUpperCase()); //compara um objeto com outro - devolve negativo, 0 ou positivo se for alfabeticamente menor, iigual ou maior
}

--------Map--------
Map<K,V>
É uma estrutura de dados genérica
Não admite repetições do objeto chave
Não possuem posição
Tem 2 tipos: Tipo Chave e Tipo Valor
Uso comum: cookies, local storage, qualquer modelo chave-valor

Principais implementações: 
-HashMap: mais rápido e não ordenado alfabeticamente
-TreeMap: mais lento e ordenado alfabeticamente pelo CompareTo
-LinkedHashMap: velocidade intermédia e elementos na ordem em que são adicionados

Alguns métodos:
• add(obj), remove(obj), contains(obj) - Baseado em equals e hashCode (senão é usada comparação de ponteiros)
• clear()
• size()
• removeIf(predicate)
• addAll(other) - união: adiciona no conjunto os elementos do outro conjunto, sem repetição --> igual ao SET
• retainAll(other) - interseção: remove do conjunto os elementos não contitos em other --> igual ao SET
• removeAll(other) - diferença: remove do conjunto os elementos contidos em other --> igual ao SET

------Exemplo-----
Map<String, String> cookies = new TreeMap<>(); //Tipo Chave e Tipo Valor | TreeMap: ordem alfabetica

cookies.put("username", "Maria");
cookies.put("email", "maria@gmail.com");
cookies.put("phone", "918463726");

cookies.remove("email");
cookies.put("phone", "911111111"); //Vai apenas atualizar - pois nao admite repetições

//Listar todos os cookies
System.out.println("----ALL COOKIES----");
for(String key : cookies.keySet()) {
	System.out.println(key + ": " + cookies.get(key));
}

//Ver se existe alguma chave com um determinado valor
System.out.println();
System.out.println("Contains 'phone' key: " + cookies.containsKey("phone"));

//Ver o valor de uma chave
System.out.println();
System.out.println("Phone number: " + cookies.get("phone"));
System.out.println("Email: " + cookies.get("email"));

//Ver tamanho
System.out.println();
System.out.println("Size: " + cookies.size());


------------ Set, List e Map ------------------
Set, List e Map são três interfaces(que possuem implementações):
Uma Lista é uma coleção ordenada de itens
Um Set é uma coleção não ordenado de itens sem registos duplicados
Um Map é uma coleção de pares chave/valor sem registos duplicados


----Converter list em set------
List<Product> list = new ArrayList<>();
list.add(new Product("TV", 900.0));
list.add(new Product("Notebook", 1200.0));
list.add(new Product("Tablet", 400.0));
list.add(new Product("Tablet", 400.0));
Set<Product> foo = new HashSet<Product>(list);
System.out.println("List  : " + list); 

----Converter list em Hashmap------
Map<String, Double> map = new HashMap<>(); 
// put every value list to Map 
for (Product p : list) { 
    map.put(p.getName(), p.getPrice()); 
} 
System.out.println("Map  : " + map); 


-------------------------------PROG FUNCIONAL E EXPRESSÕES LAMBDA---------------------------------

O que são "expressões lambda"?
Em programação funcional, expressão lambda corresponde a uma função anônima de primeira classe.
OU SEJA... é uma função sem nome(nao foi declarada) e pode ser passada como argumento para outras funções

public class Program {

public static void main(String[] args) {
	(...)
	list.sort((p1, p2) -> p1.getPrice().compareTo(p2.getPrice())); //Expressão lambda com cálculo lambda
	(...)
}


Interface Funcional - é uma interface que possui um único método abstrato 
(ex: MyComparator - aula217_ComparatorF2_NewClass)
outros: Predicate, Funcion, Consumer

//Receber funcao lambda como parametro
double sum = ps.filteredSumm(list, p -> p.getName().charAt(0) == 'T'); //recebe a lista e o predicado como argumento

------
Stream - é uma sequência de elementos de uma fonte de dados que oferece suporte a operações agregadas. Operações em stream geram novas streams
Caracteristicas: declarativa, imutável, sem efeitos colaterais, sob demanda, não há índices e só pode ser usada uma vez
exemplos: a partir de uma lista gerar uma nova com os nomes em maisculas (aula222)
	Function<Product, String> func = p -> p.getName().toUpperCase();
	List<String> names = list.stream().map(func).collect(Collectors.toList()); //no map colocar a funcao lambda
	//Funcao map so funciona para stream, portanto temos de converter a lista para stream e depois voltar a colocar para stream

Pipeline - linha de montagem
Pipeline é composto por 0 ou mais operações intermediárias e uma terminal

Operação Intermediária:
- produz uma nova stream(encadeamento)
- só executa quando uma operação terminal é invocada
exemplos: filter, map, flatmap, peek, distinct, sorted, skip, limit (*)
* short-circuit (quando encontra primeira ocorrência o processamento pára)

Operação terminal:
- produz um objeto não-stream (coleção ou outro)
- determina o fim do processamento da stream
exemplos: forEach, forEachOrdered, toArray, reduce, collect, min, max, count, anyMatch (*), allMatch (*), noneMatch (*), findFirst (*), findAny (*), 
* short-circuit (quando encontra primeira ocorrência o processamento pára)

Criar uma stream: basta chamar o método stream() ou parallelStream() a partir de qualquer objeto Collection


-------------------------------BASE DADOS - JDBC---------------------------------

JDBC - API padrão do JAVA para acesso a dados (biblioteca que vem no java para aceder a base de dados)
Pacotes: java.sql e javax.sql(suplementar para servidores)

Classes importantes do JDBC para Recuperar Dados:
-Statement - serve para montar um comando sql para ser montado
-ResultSet - representa um objeto com o resultado da consulta em forma de tabela
	o first() [move para posição 1, se houver]
	o beforeFirst() [move para posição 0]
	o next() [move para o próximo, retorna false se já estiver no último]
	o absolute(int) [move para a posição dada, lembrando que dados reais começam em 1]

Classes importantes do JDBC para Inserir Dados:
-PreparedStatement - objeto que permite montar consulta SQL, deixando os parametros para colocar depois
-executeUpdate
-Statement.RETURN_GENERATED_KEYS - recuperar ID do novo objeto inserido
-getGeneratedKeys

-------------------------------JAVAFX---------------------------------

JAVAFX é o sucessor do Swing e JAVA AWT para interfaces gráficas com Java
Usado para Desktop, web e mobile
Não faz parte do JDK, precisa de ser configurado separadamente
É projeto sobre o padrão MVC

MVC - padrão de desenvolvimento de aplicações gráficas no qual a aplicação é divida em 3 partes
- Model - consiste nos dados de domínio(classes entidades e serviços) e a sua lógica de transformação
- Views - são telas de interação com o utlizador (UI)
- Controllers - classes reponsáveis por tratar as interações do utilizador com as views - manipulação de eventos

Exemplo de um registar cliente:
Tem uma tela de desenho com o formulário - VIEW
Quando clico num botão submit vai ter um método no CONTROLLER que vai chamar um serviço/classe do MODEL para registar

-------------------------------OUTROS---------------------------------
JAVA DOC - documentação do java
nome da classe, descrição, constrotores e metodos, valores de retorno
/**


Funções puras e alta ordem
funções que não possuem efeitos colaterais, que não dependam de nenhuma informação externa a elas além de seus parâmetros

Imutabilidade - var nao altera

public static void main(String[] args) {
	boolean x = true;
	while(x) { //while (x == true)
	System.out.println(x);
	}
}

System.out.print("How many items to this order? "); int numItems = sc.nextInt(); //Vai ficar pendente na linha - caso use o sc.nextLine() cuidado
System.out.print("Product name: "); sc.nextLine(); String nomeProduto = sc.nextLine(); //Quebra de linha pendente, é preciso ler até ao fim da primeira linha

//Shape p = new Rectangle(color, width, height);
//list.add(p);
// ---OU----
list.add(new Rectangle(color, width, height)); // é feito upcasting para shape

java application/Program //linha de comandos

HashCode e Equals //FORMA DE VER SE SÃO IGUAIS
Collections.sort(list); //FORMA DE ORDENAR UMA COLEÇÃO ------> list tem de ser do tipo COMPARABLE ------> Employee implements Comparable
