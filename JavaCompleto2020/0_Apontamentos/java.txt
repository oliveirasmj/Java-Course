---------------------JAVA BASICO-----------------------------
HelloWorld.class (depois de compilados dao origem a class)
HelloWorld.java (source code)
Compiler (é compilado para bytecode e executado no JVM) - compilador - transforma em linguagem maquina
JVM - Java virtual mahine

Scanner
Scanner sc = new Scanner(System.in);
String str = sc.nextLine();

Ao criar uma variavel nao objeto é defido um quadrado com o valor la dentro
Num objeto é criado um quadrado com a posição da memória

Vantagens POO:
-Duplicação de código
-Responsabilidades em cada classe

Locale.setDefault(Locale.US); //mudar regiao por causa da virgula e ponto - casas decimais
double x = 10.2626452; int y = 3; String var = "ola"; char letra = 'A';
soutf("Double: %f - Inteiro: %d - String: %s - Letra: %c", x, y, var, letra);

int a=5, b=2; System.out.println(a/b); System.out.println((double)a/b); //Truncado e valor real

//INCREMENTO
//num=num+1
//num+=1
//num++  --> valor antigo será usado para o cálculo
//++num  --> valor antigo não será usado para o cálculo

Math.pow(5, 2)
Math.sqrt(25)

Membros de instância vs Membros estáticos/de classe
-Membros de instância tem valor diferente para cada objeto  +  É preciso instanciar
-Membros estáticos tem o mesmo valor para diferentes objetos (chamados com o nome da classe: Math.sqrt()) + não é preciso instanciar (usados para dados e funções nunca irão se modificar)


---------------------CLASSES E OBJETOS-----------------------------
Classe - representa categoria de algo (descreve caracteristicas) - modelo
Objeto - instância de uma classe - tem atributos (cor)
	Classe: int cor -> Objeto cor: vermelho
Método - é uma função que retorna algo (int/void) ou modifica(setter)
Carro c = new Carro( );

-Primitivo VS Referencia
int number; number = 35;		number|35|
Customer cust; cust = new Customer;	cust| |-------> |:Custormer|

number2 = number			number|35| number2|35|
Customer cust2; cust2=cust		cust| |-------> |:Custormer|
					cust2| |------->

private String txt; //txt = null


---------------------DEFINICAO CLASSES-----------------------------
Construtor - é o que é executado na instânciação do objeto (iniciar valores) - método para iniciar os objetos
Sobrecarga/Overloading - mais de um construtor (varios parametros) - com o mesmo nome
Encapsulamento - consiste em esconder detalhes de implementação (getters e setters e modificadores private)

This - referência para o próprio objeto (distinguir atributos e variaveis locais ou passar objeto como argumento)
Os campos devem ser privados e os metodos publicos para serem usados

Modificadores - public, private, protected
-public - visiveis por todas as classes
-private - visiveis dentro da classe
-protected - visiveis dentro da package
-(default) - visiveis dentro da package

public String toString() {
	return getId() + ", " + getName() + ", " + String.format("%.2f", getSalary());
}	

---------------------INTERACAO ENTRE OBJETOS-----------------------------
-Triangle x = new Triangle(); x.area()-> 6 --> Membros de instância (valor para cada objeto - correto)
-Triangle y = new Triangle(); x.area()-> 4 --> Membros de instância (valor para cada objeto - correto)

-Calculator calc1 = new Calculator(); calc1.PI()-> 3.14 --> Membros estáticos (não totalmente certo)
-Calculator calc2 = new Calculator(); calc2.PI()-> 3.14 --> Membros estáticos (não totalmente certo)
-double c = Calculator.PI -> Membros estáticos - Não é preciso instanciar objetos (o mais correto)

Apenas "métodos static" podem ser chamados no public static void main(String[] args) {}
Para chamar diretamente um método de uma classe(sem instanciar - Classe.metodo() ), então o método terá de ser "static"


---------------------MEMÓRIA/ARRAYS/LISTAS(AGRUPAMENTO DE OBJETOS)-----------------------------
Tipos de variáveis:
-Tipos de Referência - classes (através de ponteiros) - posição da memória fica lá dentro - Stack ------> Heap
-Tipos de Valor (primitivos) - caixas em que valor fica lá dentro - boolean, byte, char, short, int, long, float, double

Garbage collector - monitoriza os objetos alocados pelo programa (no heap) e desaloca os que não estão a ser utilizados
Ou seja - se o ponteiro desaparecer o que está no solto no Heap desaparece
Product P1 = new Product(...);
Product P2 = new Product(...);
P1 = P2;
//O que está no Heap do P1 (para onde apontava) será eliminado, pois apontará para o mesmo de P2

Desalocação por escopo - elimina as váriáveis primitivas que não serão precisas (p. ex. dentro de um if)

Wrapper classes - classes equivalentes aos tipos primitivo - Double(wrapper classe) e double(primitivo)
-usado para converter valores entre os dois tipos(ex. String to int)

-------
Array/Vetor: dados do mesmo tipo ordenados por posições
-vantagens: acesso imediato aos elementos pela posição
-desvantagens: tamanho fixo e dificuldade para inserir e eliminar

String vect[] = new String[10] //tamanho definido de array de Strings
String[] names = new String[] {"Mike", "Pedro", "Carlos"};

------
Matriz - é o nome dado a arranjos bidimensionais (do mesmo tipo, odenada)
Vantagens: acesso imediato aos elementos pela posição
Desvantagens: tamanho fixo, dificuldade para inserir e eliminar

int mat[][] = new int[n][n]; //criacao de vetor com n elementos

//Percorrer matriz	
for(int i=0; i<n; i++) {
	for(int j=0; j<n; j++) {
		mat[i][j] = sc.nextInt();
	}
}

-----
Boxing: conversão de um objeto valor para um objeto referência
int x = 20; Object obj = x;
UnBoxing: conversão de um objeto referência para um objeto valor
int x = 20; Object obj = x; int y = (int) obj;

FOR VS FOREACH:

String[] vect = new String[] {"Mike", "Pedro", "Carlos"};
for(int i=0; i<vect.length; i++){
     sout(vect[i]);
}
for(String obj : vect){
     sout(obj);
}

-------
List:
-é uma estrutura de dados 
-do mesmo tipo
-ordenada
-inicia vazia, sem dizer o valor inicial
-cada elemento é um nó
-não é uma classe, é uma interface - não pode ser instanciada
	private List<String> list = new List<>(); -- ERRADO - nao se pode instanciar uma interface

Classes que implementam List: ArrayList, LinkedList, etc - forma de instanciar
	private List<String> list = new ArrayList<>(); -- CERTO - criar uma lista implementando o arraylist

Vantagens: 
-tamanho variável e facilidade para inserir e eliminar
Desvantagens: 
-acesso sequencial - é preciso percorrer toda a lista para chegar a um elemento
-tipo de dados não pode ser primitivo, apenas o wraper

Coleções: ArrayList(listas de objetos), HashMaps(mapeia chaves para valores)
https://www.guj.com.br/t/por-favor-qual-e-a-diferenca-dentre-arraylist-e-list/69167/2
NAO PODE SER TIPO DADOS PRIMITIVO
add, get, size, remove, etc...

------
Datas:
SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
System.out.print("Bith date (DD/MM/YYY): "); Date birthDate = sdf.parse(sc.next());
System.out.print(sdf.format(birthDate));

Date birthDate2 = new Date();
System.out.println(sdf.format(birthDate2));
------
Append:
public String toString() {
	StringBuilder sb = new StringBuilder();
	sb.append("Order moment: " + sdf.format(moment) + "\n");
	sb.append("Order status" + status + "\n");
	sb.append("Client: " + client + "\n");
	return sb.toString();
}

-------
Enumerados: conjunto de nomes significativos (exemplo: ciclo de vida de uma encomenda)
public enum OrderStatus {
	PENDING_PAYMENT,
	PROCESSING,
	SHIPPED,
	DELIVERED;
}

System.out.print("Introduza o status: "); OrderStatus status = OrderStatus.valueOf(sc.next());

------
Composição - é um tipo de associação que permite que um objeto contenha outro (diamante preto)
(Relação tem-um ou tem vários)

public class Order {
	private Date moment;
	private OrderStatus status;
	private Client client; //uma encomenda pode ter um cliente (tem referência para o Cliente)
	private List<OrderItem> orders = new ArrayList<OrderItem>(); //uma encomenda pode ter vários OrderItem
}

------
Iterações:
foreach - percorre ate ao fim, nao pode ser alterada (nao remove)
while - nao precisa ir ate ao fim
Iterator - nao precisa ir ate ao fim - listar, remover


-------------------HERANÇA, POLIMORF, INTERFACE---------------------------

Herança - é uma forma que permite que uma classe herde todos os dados da outra - classes pai/filho (extends) - lê-se "é um"
-Classe Pai = generalização/superclasse; Classe filho = especialização/subclasse
-VANTAGENS: evita repetição de código e no caso de ser vir a alterar codigo
Animal -> Mamifero e Reptil -> Cão -> Dalmata
-------
public class Carro extends Veiculo{
	private Integer numCavalos;

	public Carro() {
		super();
	}
	
	public Carro(Integer numRodas, Integer numCavalos) {
		super(numRodas);
		this.numCavalos = numCavalos;
	}
	
	public void chamarMetodo(){
		//System.out.println(super.getNumRodas()); //chamar um metodo da superclasse
	}
}
-------
Métodos são herdados por todas as classes
Sobreposição - é a implementação de um método da superclasse na subclasse - @override

Polimorfismo - permite que variaveis de um mesmo tipo apontem para objetos de tipos diferentes, tendo comportamentos diferentes
Account x = new Account(); //possui todos os atributos de Account
Account y = new SavingsAccount(); //possui todos os atributos de Account mais os de SavingsAccount - converte para SavingsAccount 
//Tanto x como y são variáveis do mesmo tipo (Account), mas objetos de tipos diferentes na memória

x.withdraw(50.0); 
y.withdraw(50.0);
//Métodos com comportamentos diferentes caso o withdraw de y(SavingsAccount) seja implementado de forma diferente

Outra vantagem: quando se colocam numa lista, a lista só pode ser de um tipo, logo será do tipo Account

----
(abstract) - classes filho conseguirem chamar metodos com o mesmo nome mas de forma a fazerem coisas diferentes

-----
//Sobreposicao
@Override
public void withdraw(double amount) { //chamar método da superclasse e escrever o código à nossa maneira
	super.withdraw(amount); //Escrever código igual à super classe
	balance -= 2.0; //Mas aplicar uma taxa
}
-----
Upcasting - casting da subclasse para superclasse (polimorfismo)
Downcasting - casting da superclasse para subclasse (instance of, equals)

public static void main(String[] args) {	
	Veiculo v = new Veiculo();
	Carro c = new Carro();
	Veiculo xpto = new Carro();

	v.getNumRodas(); // o que v consegue ver
	c.getNumRodas(); c.getNumCavalos(); // o que c consegue ver
	xpto.getNumRodas(); // o que xpto consegue ver
		
	// UPCASTING - converter veiculo em carro
	Veiculo v2 = c; // não dá erro porque carro é um veículo
	Veiculo v3 = new Carro(); //outra forma - não dá erro porque carro é um veículo
		
	// DOWNCASTING - converter carro em veiculo
	//Carro c2 = v; //Não se pode converter de Veiculo para carro
	Carro c2 = (Carro) v3; //Fazendo a conversao manual já é possível converter para Carro
		
	//Verificar se um objeto é um Carro
	if(v3 instanceof Carro) {
		System.out.println("É um carro");
	}
}

-----
Instance of (é um) - verifica se um objeto é de um tipo de classe
Ferrari ferrari = new Ferrari();
if (ferrari instance of Vehicle)
-----
final
(campos - valor não altera)
(classe - evita que classe seja herdada) - impede herança de uma classe
(método - evita que método seja sobreposto) - impede herança de um método(sobreposicao)

private final int MAX_ALUNOS_TURMA = 25 //constante valor fixo
private static int numAlunos = 0; //mesmo valor	para todas os objetos

-------------------ABSTRATA---------------------------
São classes que não podem ser instanciadas
Métodos abstratos não têm corpo na classe pai - mover()
Apenas tem corpo na classe filho - voar, nadar, saltar...
Classe com metodos abstratos é uma CLASSE ABSTRATA(nao podem ser instanciadas)
Apenas as filho podem ser instanciadas


-------------------INTERFACE---------------------------
é um conjunto de métodos vazios que são implementados noutra classe

VS: https://www.devmedia.com.br/interfaces-x-classes-abstratas/13337

-------------------------------EXCEPÇÕES---------------------------------
Programação defensiva
Lançamento e tratamento de exceções
Reporte de erros

Objetivo: prevenir que erros afectem o sistema

Remover aluno com id que não existe
try - instruções a proteger
catch - reportar
finally - faz sempre

RuntimeException - compilador nao obriga a tratar - programa termina
Exception - compilador obriga a tratar

Throws - lançam uma exceção verificada devem indicá-lo incluindo uma cláusula throws

-------------------------------OUTROS---------------------------------
JAVA DOC - documentação do java
nome da classe, descrição, constrotores e metodos, valores de retorno
/**


Funções puras e alta ordem
funções que não possuem efeitos colaterais, que não dependam de nenhuma informação externa a elas além de seus parâmetros

Imutabilidade - var nao altera

public static void main(String[] args) {
	boolean x = true;
	while(x) { //while (x == true)
	System.out.println(x);
	}
}

System.out.print("How many items to this order? "); int numItems = sc.nextInt(); //Vai ficar pendente na linha - caso use o sc.nextLine() cuidado
System.out.print("Product name: "); sc.nextLine(); String nomeProduto = sc.nextLine(); //Quebra de linha pendente, é preciso ler até ao fim da primeira linha